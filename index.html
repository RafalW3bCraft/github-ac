<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>INDEX-GAMBLER ‚Äî RafalW3bCraft</title>
<meta name="theme-color" content="#0a0f14"/>
<style>
:root{
  --bg:#070b10; --panel:#0c141e; --ink:#dff7ff; --muted:#86a9c2;
  --acc:#00ffc6; --acc2:#ff3d81; --gold:#ffd166; --good:#2af07a; --bad:#ff5050; --blue:#66c2ff;
  --edge:#193447; --edge2:#24546e; --glass:#0a1621cc;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--ink);
  background:
    radial-gradient(1400px 700px at 115% -10%, rgba(0,255,198,.10), transparent),
    radial-gradient(1100px 600px at -15% 110%, rgba(255,61,129,.10), transparent),
    #061018;
  font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
header{
  position:sticky; top:0; z-index:10;
  display:flex; align-items:center; gap:10px; padding:12px 14px;
  background:linear-gradient(180deg, #08121b 0%, #09131d 100%); border-bottom:1px solid var(--edge);
  box-shadow: 0 2px 18px rgba(0,0,0,.25);
  backdrop-filter: blur(10px);
}
.brand{display:flex; gap:10px; align-items:center}
.brand .logo{font-size:22px; filter: drop-shadow(0 0 8px rgba(0,255,198,.35))}
.brand h1{font-size:16px; margin:0; letter-spacing:.6px; color:var(--acc)}
header .right{margin-left:auto; display:flex; align-items:center; gap:8px}
.pill{padding:6px 10px; border:1px solid var(--edge2); border-radius:999px; background:#0c1a26; color:#aee6ff; font-size:12px}
.btn{cursor:pointer; border:1px solid var(--edge2); background:#0f1e2a; color:var(--ink); padding:10px 12px; border-radius:12px; transition:.15s transform; user-select:none}
.btn:active{transform:translateY(1px)}
.btn:disabled{opacity:.5; cursor:not-allowed; pointer-events:none}
.btn.primary{background:linear-gradient(180deg,#00ffc6,#00d3a7); border-color:#00dabb; color:#002c25; font-weight:800}
.btn.ghost{background:transparent}
.btn.warn{background:#2a1b0d; border-color:#76501a; color:#ffdca0}
.wrap{display:grid; grid-template-columns:1fr; gap:12px; padding:12px}
@media(min-width:1100px){ .wrap{grid-template-columns:300px 1fr 340px} }
.card{background:linear-gradient(180deg,#0a141d,#0b1721); border:1px solid var(--edge); border-radius:14px; overflow:hidden}
.card h2{margin:0; padding:10px 12px; border-bottom:1px dashed var(--edge2); font-size:13px; color:#92e7ff; letter-spacing:.6px}
.pad{padding:12px}
.row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
.col{display:flex; flex-direction:column; gap:10px}
.kpi{background:#08131c; border:1px solid var(--edge); border-radius:12px; padding:10px}
.score{font-size:24px; color:#c9fbff}
.sub{font-size:12px; color:var(--muted)}
.badge{font-size:11px; padding:6px 8px; border:1px solid var(--edge2); border-radius:10px; background:#0c1620}
hr.sep{border:0; border-top:1px dashed var(--edge2); margin:8px 0}
input,select{background:#0c1924; border:1px solid var(--edge2); border-radius:12px; color:#e6fbff; padding:10px; min-width:0}

/* Tabs */
.tabs{display:flex; gap:8px; flex-wrap:wrap}
.tab{flex:1; text-align:center; background:#0d1a26; border:1px solid var(--edge); border-radius:12px; padding:10px; cursor:pointer; user-select:none}
.tab.active{background:linear-gradient(180deg,#0d2330,#0b1c29); box-shadow:0 0 0 1px #1f5a76 inset}

/* Slots ‚Äî 5x3 optimized */
.slotsHead{display:flex; align-items:flex-end; justify-content:space-between}
.reels{position:relative; height:280px; display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin:10px 0}
.reel{background:#07131c; border:1px solid var(--edge2); border-radius:12px; overflow:hidden; position:relative}
.strip{position:absolute; left:0; right:0; top:0; will-change:transform}
.cell{height:90px; display:grid; place-items:center; font-size:34px; text-shadow:0 0 10px rgba(255,255,255,.15)}
.payline{position:absolute; left:0; right:0; height:2px; background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.35; pointer-events:none}
.winGlow{box-shadow:0 0 0 1px #ffe29e inset, 0 0 18px rgba(255,209,102,.35); animation:glow .9s ease-in-out infinite alternate}
@keyframes glow{from{box-shadow:0 0 0 1px #ffe29e inset, 0 0 10px rgba(255,209,102,.2)}to{box-shadow:0 0 0 1px #ffe29e inset, 0 0 26px rgba(255,209,102,.5)}}
.bigWin{font-size:36px; color:#ffe29e; text-shadow:0 0 14px rgba(255,209,102,.5)}
.payTable{font-size:12px}
.spark{position:absolute; width:8px; height:8px; border-radius:50%; background:radial-gradient(circle at 30% 30%, #fff, #ffd166 45%, transparent 60%); pointer-events:none;}

/* Runner Rush */
.runnerWrap{position:relative; height:420px; border-radius:14px; overflow:hidden; border:1px solid var(--edge2); background:#061018}
canvas#runner{display:block; width:100%; height:420px; background:linear-gradient(#061018 60%, #0b1a26)}
.hud{position:absolute; top:8px; left:8px; right:8px; display:flex; justify-content:space-between; gap:8px; pointer-events:none}
.hud .tag{background:#0b1620aa; border:1px solid var(--edge2); padding:6px 10px; border-radius:10px}
.ctaRow{position:absolute; bottom:10px; left:0; right:0; display:flex; justify-content:center; gap:12px}
.gbtn{pointer-events:auto; padding:10px 12px; border-radius:12px; border:1px solid var(--edge2); background:#0f1e2a; color:#e8fbff}
.gbtn.primary{background:linear-gradient(180deg,#00ffc6,#00d3a7); color:#00332a; border-color:#00d3b7}

/* Leaderboard & log */
.log{max-height:280px; overflow:auto; font-size:12px}
.toast{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background:#081620; color:#defcff; border:1px solid var(--edge2); border-radius:12px; padding:10px 14px; box-shadow:0 10px 30px rgba(0,0,0,.45); opacity:0; pointer-events:none; transition:.18s opacity,.18s transform; z-index:20}
.toast.show{opacity:1; transform:translateX(-50%) translateY(-6px)}

/* Progressive features */
.hot-streak{color:#ff6b35; font-weight:bold; animation:pulse 1s infinite}
.near-win{color:#ffdd44; animation:shimmer 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.7}}
@keyframes shimmer{0%,100%{opacity:1}50%{opacity:0.6}}

/* Theme toggle (subtle) */
.themeLight:root, .themeLight body{ --bg:#f7fbff; --panel:#ffffff; --ink:#0c1a22; --muted:#4a6b82; background:#eaf6ff }
.themeLight header{ background:#ffffffcc; }
.themeLight .card{ background:#ffffff; }
.themeLight .reel{ background:#f3faff }
.themeLight .pill{ background:#eef7ff }
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo">üé∞</div>
    <h1>GO-GAMBLER</h1>
    <div class="pill">by <b>RafalW3bCraft</b></div>
  </div>
  <div class="right">
    <div id="balancePill" class="pill">Balance: <b id="bal">‚Äî</b></div>
    <button id="themeBtn" class="btn ghost">üåó Theme</button>
    <button id="sfxBtn" class="btn ghost">üîä SFX</button>
  </div>
</header>

<div class="wrap">
  <!-- LEFT: Dashboard -->
  <section class="card">
    <h2>Casino Dashboard</h2>
    <div class="pad col">
      <div class="kpi">
        <div class="sub">Balance</div>
        <div id="balance" class="score">‚Äî</div>
      </div>
      <div class="row">
        <label class="sub">Bet per spin</label>
        <input id="bet" type="number" min="1" step="10" value="100" style="width:120px"/>
        <button id="betMax" class="btn">MAX</button>
        <button id="betHalf" class="btn">¬Ω</button>
        <button id="betDouble" class="btn">2√ó</button>
      </div>
      <div class="kpi">
        <div class="sub">Recent Wins</div>
        <div id="recent" class="log"></div>
      </div>
      <div class="kpi">
        <div class="sub">Local Leaderboard</div>
        <div id="lb" class="log"></div>
        <button id="saveLB" class="btn" style="margin-top:6px">Save Session ‚Üí Leaderboard</button>
      </div>
      <div class="kpi">
        <div class="sub">Missions & Rewards</div>
        <div id="missions" class="col">
          <!-- populated by JS -->
        </div>
      </div>
      <div class="kpi">
        <div class="sub">Bonus Tracker</div>
        <div id="bonusTracker" class="col">
          <div class="badge">Streak: <span id="streakCount">0</span></div>
          <div class="badge">Next Bonus: <span id="nextBonus">‚Äî</span></div>
        </div>
      </div>
    </div>
  </section>

  <!-- CENTER: Games -->
  <section class="card">
    <h2>Games</h2>
    <div class="pad">
      <div class="tabs">
        <div class="tab active" data-tab="slotsTab">üé≤ Neo Slots</div>
        <div class="tab" data-tab="runnerTab">üèÉ Runner Rush</div>
      </div>

      <!-- SLOTS -->
      <div id="slotsTab" class="col" style="margin-top:10px">
        <div class="slotsHead">
          <div>
            <div class="sub">Provably Fair</div>
            <div class="sub">Server Seed Hash: <span id="srvHash">‚Äî</span></div>
            <div class="sub">Client Seed: <span id="cliSeed">‚Äî</span></div>
            <div class="sub">Nonce: <span id="nonce">‚Äî</span></div>
          </div>
          <div style="text-align:right">
            <div class="sub">Payout</div>
            <div id="payoutBox" class="bigWin">‚Äî</div>
          </div>
        </div>

        <div class="reels" id="reels"></div>

        <div class="row">
          <button id="spinBtn" class="btn primary">SPIN</button>
          <button id="autoBtn" class="btn">Auto (25)</button>
          <span id="slotStatus" class="badge">Ready</span>
          <span id="volatilityMeter" class="badge">Volatility: Low</span>
        </div>

        <div class="kpi">
          <div class="sub">Paytable & Lines</div>
          <div class="row">
            <div class="payTable">
              <b>Symbols:</b> üíé Wild (substitutes), ‚≠ê Scatter (free spins), üçí, üçã, üü©, üîî, 7Ô∏è‚É£<br/>
              5-of-a-kind pays: üíé√ó25, 7Ô∏è‚É£√ó12, üîî√ó8, üçí√ó5, üçã√ó3, üü©√ó2<br/>
              Any 3+ ‚≠ê scatters ‚Üí 5 free spins.
            </div>
          </div>
        </div>
      </div>

      <!-- RUNNER -->
      <div id="runnerTab" style="display:none; margin-top:10px">
        <div class="runnerWrap">
          <canvas id="runner" width="900" height="420"></canvas>
          <div class="hud">
            <div class="tag">Score: <b id="rScore">0</b></div>
            <div class="tag">Coins: <b id="rCoins">0</b></div>
            <div class="tag">Speed: <b id="rSpeed">1.0√ó</b></div>
          </div>
          <div class="ctaRow">
            <button id="rStart" class="gbtn primary">Start</button>
            <button id="rPause" class="gbtn">Pause</button>
            <button id="rHelp" class="gbtn">?</button>
          </div>
        </div>
        <div class="sub" style="margin-top:6px">Swipe / arrow keys: move lanes ¬∑ Swipe up/Space: jump ¬∑ Down: slide</div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Activity & Settings -->
  <section class="card">
    <h2>Activity & Settings</h2>
    <div class="pad col">
      <div class="kpi">
        <div class="sub">Session Stats</div>
        <div class="row">
          <span class="badge">Spins: <b id="statSpins">0</b></span>
          <span class="badge">RTP (est): <b id="statRTP">‚Äî</b></span>
          <span class="badge">Biggest Win: <b id="statBig">0</b></span>
        </div>
      </div>
      <div class="kpi">
        <div class="sub">Sound</div>
        <div class="row">
          <button id="sfxToggle" class="btn">üîä Toggle SFX</button>
          <button id="confettiTest" class="btn">‚ú® Test Particles</button>
        </div>
      </div>
      <div class="kpi">
        <div class="sub">Fairness Reveal (last spin)</div>
        <div class="sub">Server Seed: <span id="revealSrv">‚Äî</span></div>
      </div>
      <div class="kpi">
        <div class="sub">Reset / Export</div>
        <div class="row">
          <button id="resetAll" class="btn warn">Reset All</button>
          <button id="exportBtn" class="btn">Export Data</button>
          <input id="importFile" type="file" accept="application/json" style="display:none"/>
          <button id="importBtn" class="btn">Import</button>
        </div>
      </div>
    </div>
  </section>
</div>

<div id="toast" class="toast">Toast</div>

<script>
/* =========================
   Utils & SFX (Optimized)
========================= */
const $ = id=>document.getElementById(id);
const fmt = n => Number(n).toLocaleString();
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rng = (min,max)=>Math.random()*(max-min)+min;

let toastTimer;
const toast=(m)=>{
  const t=$('toast');
  t.textContent=m;
  t.classList.add('show');
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>t.classList.remove('show'),1400);
};

let SFX_ON = true;
let audioContext = null;

function initAudioContext(){
  if(!audioContext){
    audioContext = new (window.AudioContext||window.webkitAudioContext)();
    if(audioContext.state === 'suspended') audioContext.resume();
  }
}

function beep(freq=880, dur=.06, type='triangle', vol=.18){
  if(!SFX_ON) return;
  try{
    initAudioContext();
    const o = audioContext.createOscillator();
    const g = audioContext.createGain();
    o.type=type; o.frequency.value=freq; 
    o.connect(g); g.connect(audioContext.destination);
    g.gain.value=0.0001; 
    g.gain.exponentialRampToValueAtTime(vol, audioContext.currentTime+.01);
    g.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime+dur);
    o.start(); o.stop(audioContext.currentTime+dur+.02);
  }catch(e){console.warn('Audio error:',e);}
}

/* =========================
   Enhanced Persistence System
========================= */
const STORE_KEY='gogambler_store_v3';
const BACKUP_KEY='gogambler_backup_v3';

const store = {
  data: { 
    bal:50000, bet:100, spins:0, won:0, biggest:0, 
    history:[], leaderboard:[], theme:'dark', sfx:true, missions:{},
    streak:0, lastWin:0, totalLoss:0, sessionStart:Date.now(),
    volatilityLevel: 'low', nearWins: 0, bonusProgress: 0
  },
  
  load(){ 
    try{ 
      const j=JSON.parse(localStorage.getItem(STORE_KEY)||'null'); 
      if(j) {
        this.data = {...this.data, ...j};
        // Migration for new fields
        if(!this.data.volatilityLevel) this.data.volatilityLevel = 'low';
        if(!this.data.nearWins) this.data.nearWins = 0;
        if(!this.data.bonusProgress) this.data.bonusProgress = 0;
      }
    }catch(e){
      console.warn('Failed to load data, trying backup...');
      this.loadBackup();
    }
  },
  
  save(){ 
    try{
      const dataStr = JSON.stringify(this.data);
      localStorage.setItem(STORE_KEY, dataStr);
      // Create backup every 10 saves
      if(this.data.spins % 10 === 0){
        localStorage.setItem(BACKUP_KEY, dataStr);
      }
    }catch(e){
      console.error('Failed to save data:', e);
      toast('‚ö†Ô∏è Save failed - storage full?');
    }
  },
  
  loadBackup(){
    try{
      const backup = JSON.parse(localStorage.getItem(BACKUP_KEY)||'null');
      if(backup) {
        this.data = {...this.data, ...backup};
        toast('üìÅ Restored from backup');
      }
    }catch(e){
      console.error('Backup also failed:', e);
    }
  },
  
  pushHistory(entry){ 
    this.data.history.unshift(entry); 
    this.data.history = this.data.history.slice(0,100); // Reduced for performance
    this.save(); 
    requestAnimationFrame(renderRecent); // Optimize rendering
  }
};

/* =========================
   Optimized Fairness (HMAC)
========================= */
const sha256Cache = new Map();
const hmacCache = new Map();

const sha256=async s=>{
  if(sha256Cache.has(s)) return sha256Cache.get(s);
  const buf=new TextEncoder().encode(s);
  const h=await crypto.subtle.digest('SHA-256', buf);
  const result = [...new Uint8Array(h)].map(b=>b.toString(16).padStart(2,'0')).join('');
  sha256Cache.set(s, result);
  return result;
};

const hmac=async (key,msg)=>{
  const cacheKey = key+':'+msg;
  if(hmacCache.has(cacheKey)) return hmacCache.get(cacheKey);
  
  const enc=new TextEncoder();
  const cryptoKey=await crypto.subtle.importKey('raw',enc.encode(key),{name:'HMAC',hash:'SHA-256'},false,['sign']);
  const sig=await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(msg));
  const result = [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
  hmacCache.set(cacheKey, result);
  return result;
};

const uniFromHex = hex => {
  const slice = hex.slice(0,13);
  return parseInt(slice,16)/Math.pow(16,13);
};

const Fair = {
  serverSeed:'', serverHash:'', clientSeed:'', nonce:0,
  async newPack(){
    this.clientSeed = Math.random().toString(36).slice(2);
    this.serverSeed = Math.random().toString(36).slice(2)+Math.random().toString(36).slice(2);
    this.serverHash = await sha256(this.serverSeed);
    this.nonce = 0;
    $('srvHash').textContent=this.serverHash.slice(0,16)+'...';
    $('cliSeed').textContent=this.clientSeed;
    $('nonce').textContent=String(this.nonce);
  }
};

/* =========================
   Psychology & Engagement Systems
========================= */
const Psychology = {
  
  // Adaptive RTP based on player behavior
  calculateDynamicRTP(baseRTP = 0.85){
    const session_duration = (Date.now() - store.data.sessionStart) / (1000 * 60); // minutes
    const loss_streak = store.data.spins - store.data.lastWin;
    
    // Lower RTP for extended sessions to increase house edge
    let rtp = baseRTP;
    if(session_duration > 30) rtp *= 0.92; // -8% after 30min
    if(session_duration > 60) rtp *= 0.88; // -12% after 1hr
    if(loss_streak > 20) rtp *= 1.05; // Small mercy boost
    
    return Math.max(0.75, Math.min(0.95, rtp)); // Clamp between 75-95%
  },
  
  // Near-miss generation to create false hope
  generateNearMiss(){
    store.data.nearWins++;
    if(store.data.nearWins % 3 === 0){
      toast('üéØ So close! Try again!');
      $('slotStatus').classList.add('near-win');
      setTimeout(()=>$('slotStatus').classList.remove('near-win'), 3000);
    }
    return Math.random() < 0.15; // 15% chance to show near-miss symbols
  },
  
  // Bonus progress to keep players engaged
  updateBonusProgress(){
    store.data.bonusProgress = (store.data.bonusProgress + 1) % 50;
    const remaining = 50 - store.data.bonusProgress;
    $('nextBonus').textContent = remaining + ' spins';
    
    if(store.data.bonusProgress === 0 && store.data.spins > 0){
      // Small bonus every 50 spins
      const bonus = Math.floor(store.data.bet * 0.5);
      store.data.bal += bonus;
      updateBal();
      toast(`üéÅ Bonus! +${fmt(bonus)} credits!`);
      beep(1500, 0.1, 'sine', 0.3);
    }
  },
  
  // Volatility simulation
  adjustVolatility(){
    const winRate = store.data.won / Math.max(1, store.data.spins * store.data.bet);
    if(winRate > 0.5) store.data.volatilityLevel = 'high';
    else if(winRate > 0.3) store.data.volatilityLevel = 'medium';
    else store.data.volatilityLevel = 'low';
    
    $('volatilityMeter').textContent = `Volatility: ${store.data.volatilityLevel.charAt(0).toUpperCase() + store.data.volatilityLevel.slice(1)}`;
  }
};

/* =========================
   UI Bindings (Optimized)
========================= */
const updateBal=()=>{ 
  const balStr = fmt(store.data.bal);
  $('bal').textContent = balStr;
  $('balance').textContent = balStr;
  
  // Color coding for balance
  const balEl = $('balance');
  if(store.data.bal < 1000) balEl.style.color = '#ff5050';
  else if(store.data.bal < 10000) balEl.style.color = '#ffdd44';
  else balEl.style.color = '#c9fbff';
};

// Debounced bet input
let betTimeout;
$('bet').oninput=e=>{ 
  if(betTimeout) clearTimeout(betTimeout);
  betTimeout = setTimeout(()=>{
    store.data.bet = Math.max(1,Math.floor(+e.target.value||0)); 
    store.save(); 
  }, 300);
};

$('betMax').onclick=()=>{ 
  const maxBet = Math.min(store.data.bal, store.data.bal * 0.1); // Max 10% of balance
  store.data.bet = maxBet; 
  $('bet').value=store.data.bet; 
  store.save(); 
};

$('betHalf').onclick=()=>{ 
  store.data.bet = Math.max(1, Math.floor(store.data.bet/2)); 
  $('bet').value=store.data.bet; 
  store.save(); 
};

$('betDouble').onclick=()=>{ 
  const newBet = Math.min(store.data.bal, store.data.bet*2);
  store.data.bet = newBet;
  $('bet').value=store.data.bet; 
  store.save(); 
};

$('saveLB').onclick=()=>{
  const score = store.data.bal;
  const row = { name:'Player', score, time: new Date().toLocaleString() };
  store.data.leaderboard.push(row);
  store.data.leaderboard.sort((a,b)=>b.score-a.score);
  store.data.leaderboard = store.data.leaderboard.slice(0,20);
  store.save(); renderLB(); toast('Session saved to leaderboard');
};

$('resetAll').onclick=()=>{
  if(!confirm('Reset all local data? This cannot be undone!')) return;
  localStorage.removeItem(STORE_KEY);
  localStorage.removeItem(BACKUP_KEY);
  sha256Cache.clear();
  hmacCache.clear();
  store.load(); 
  Fair.newPack();
  refreshAll();
  toast('Reset complete');
};

$('exportBtn').onclick=()=>{
  const blob = new Blob([JSON.stringify(store.data,null,2)], {type:'application/json'});
  const a = document.createElement('a'); 
  a.href=URL.createObjectURL(blob); 
  a.download='go-gambler-export.json'; 
  a.click(); 
  URL.revokeObjectURL(a.href);
};

$('importBtn').onclick=()=>$('importFile').click();

$('importFile').onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  const fr=new FileReader(); fr.onload=()=>{
    try{ 
      const j=JSON.parse(fr.result); 
      if(j && typeof j==='object'){ 
        store.data=j; 
        store.save(); 
        refreshAll(); 
        toast('Imported successfully'); 
      } 
    }catch{ toast('Invalid file format'); }
  }; fr.readAsText(f);
};

$('sfxBtn').onclick=()=>{ 
  store.data.sfx=!store.data.sfx; 
  SFX_ON=store.data.sfx; 
  store.save(); 
  toast(`SFX ${SFX_ON?'on':'off'}`); 
};

$('sfxToggle').onclick=()=>$('sfxBtn').click();

$('themeBtn').onclick=()=>{
  store.data.theme = store.data.theme==='dark'?'light':'dark';
  applyTheme();
  store.save();
};

function applyTheme(){
  if(store.data.theme==='light'){ 
    document.documentElement.classList.add('themeLight'); 
  }else{ 
    document.documentElement.classList.remove('themeLight'); 
  }
}

/* =========================
   Optimized Tabs
========================= */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click',()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active')); 
    t.classList.add('active');
    const id = t.dataset.tab;
    ['slotsTab','runnerTab'].forEach(s=>{
      const el = $(s);
      el.style.display = (s===id) ? 'block' : 'none';
    });
  });
});

/* =========================
   Neo Slots (REDUCED PAYOUT VERSION)
========================= */
const reelsEl = $('reels');
const ROWS=3, COLS=5, CELL_H=90;

// Reduced payout symbols with lower weights for high-paying ones
const SYMS = [
  {k:'WILD', e:'üíé', pay:[0,0,10,20,25], weight:2, wild:true}, // Much lower payouts
  {k:'SCAT', e:'‚≠ê', pay:[0,0,0,1,2], weight:3, scatter:true}, // Reduced scatter pay
  {k:'SEVEN',e:'7Ô∏è‚É£', pay:[0,0,3,8,12], weight:4}, // Reduced from 50 to 12
  {k:'BELL', e:'üîî', pay:[0,0,2,5,8], weight:6}, // Reduced from 25 to 8
  {k:'CHERRY',e:'üçí', pay:[0,0,1,3,5], weight:8}, // Reduced from 15 to 5
  {k:'LEMON', e:'üçã', pay:[0,0,1,2,3], weight:12}, // Reduced from 10 to 3
  {k:'BAR',  e:'üü©', pay:[0,0,0,1,2], weight:16} // Reduced from 5 to 2
];

const PAYLINES = [
  [0,0,0,0,0], [2,2,2,2,2], [1,1,1,1,1],
  [0,1,2,1,0], [2,1,0,1,2],
  [0,0,1,2,2], [2,2,1,0,0], [1,0,0,0,1], [1,2,2,2,1], [0,1,1,1,2]
];

let strips=[], grid=[], spinning=false, autoLeft=0, freeSpins=0;
let reelAnimations = []; // Track animations for cleanup

function buildReels(){
  reelsEl.innerHTML='';
  strips.length=0;
  reelAnimations.forEach(anim => anim.cancel());
  reelAnimations = [];
  
  for(let c=0;c<COLS;c++){
    const reel=document.createElement('div'); reel.className='reel';
    const strip=document.createElement('div'); strip.className='strip'; 
    strip.style.transform='translateY(0px)';
    
    // Build weighted symbol pool
    const pool=[]; 
    SYMS.forEach(s=>{ 
      for(let i=0;i<s.weight;i++) pool.push(s); 
    });
    
    // Create symbol strip
    const tall=[], stripSize = 25; // Reduced for performance
    for(let i=0;i<stripSize;i++){ 
      tall.push(pool[Math.floor(Math.random()*pool.length)]); 
    }
    
    // Render cells efficiently
    const fragment = document.createDocumentFragment();
    tall.forEach(sym=>{
      const cell=document.createElement('div'); 
      cell.className='cell'; 
      cell.textContent=sym.e; 
      cell.dataset.k=sym.k; 
      fragment.appendChild(cell);
    });
    strip.appendChild(fragment);
    
    reel.appendChild(strip); 
    reelsEl.appendChild(reel); 
    strips.push({el:strip, tall, offset:0});
  }
  
  // Add paylines with throttled creation
  requestAnimationFrame(()=>{
    document.querySelectorAll('.payline').forEach(e=>e.remove());
    PAYLINES.forEach((line, idx)=>{
      const y = yFromRow(line[0]);
      const pl=document.createElement('div'); 
      pl.className='payline'; 
      pl.style.top = (y+CELL_H/2)+'px';
      reelsEl.appendChild(pl);
    });
  });
}

function yFromRow(r){ return r * CELL_H }

function captureGrid() {
  grid = [];
  for (let c = 0; c < COLS; c++) {
    const reel = strips[c];
    const transY = reel.offset % reel.tall.length;
    const arr = [];
    for (let r = 0; r < ROWS; r++) {
      const idx = (transY + r) % reel.tall.length;
      arr.push(reel.tall[idx]);
    }
    grid.push(arr);
  }
}

function displayWin(lines, totalMul){
  // Efficient win display with reduced effects
  document.querySelectorAll('.winGlow').forEach(c=>c.classList.remove('winGlow'));
  
  lines.forEach(L=>{
    L.indices.forEach(({c,r})=>{
      const strip = strips[c];
      const cellIndex = (strip.offset + r) % strip.tall.length;
      const cell = strip.el.children[cellIndex];
      if(cell) {
        cell.classList.add('winGlow');
        setTimeout(()=>cell.classList.remove('winGlow'), 1000); // Shorter duration
      }
    });
  });
  
  $('payoutBox').textContent = 'x'+totalMul.toFixed(2);
  
  // Reduced confetti for big wins only
  if(totalMul > 5){
    confettiBurst(reelsEl.getBoundingClientRect(), Math.min(30, totalMul*2));
  }
}

function computePayout(bet){
  // REDUCED PAYOUT LOGIC - Strategic house advantage
  const M = Array.from({length:ROWS}, (_,r)=> Array.from({length:COLS}, (_,c)=> grid[c][r]));
  
  // Scatters - reduced free spins
  let scat=0; 
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(M[r][c].scatter) scat++;
  let freeAward = (scat>=3) ? 5 : 0; // Reduced from 8 to 5

  let totalMul=0, winLines=[];
  
  for(const line of PAYLINES){
    let base=null, count=0, wildCount=0;
    for(let c=0;c<COLS;c++){
      const r=line[c], sym=M[r][c];
      if(sym.scatter) break;
      if(sym.wild){ wildCount++; count++; continue; }
      if(!base){ base=sym; count++; }
      else if(sym.k===base.k){ count++; }
      else break;
    }
    
    if(count>=3){
      const effCount = count;
      if(!base){
        base = SYMS.filter(s=>!s.scatter && !s.wild).sort((a,b)=>b.pay[effCount]-a.pay[effCount])[0];
      }
      const pay = base.pay[effCount] || 0;
      if(pay>0){
        totalMul += pay;
        const indices=[];
        for(let c=0;c<effCount;c++){ indices.push({c, r:line[c]}); }
        winLines.push({line, count:effCount, base:base.k, pay, indices});
      }
    }
  }
  
  // Scatter pays - heavily reduced
  if(scat>=3){ 
    totalMul += SYMS.find(s=>s.scatter).pay[Math.min(5,scat)] || 0; 
  }
  
  // Apply dynamic RTP and house edge
  const dynamicRTP = Psychology.calculateDynamicRTP();
  let finalMul = (totalMul/20) * dynamicRTP; // Heavy division + RTP reduction
  
  // Additional house edge mechanisms
  if(Math.random() < 0.1 && finalMul > 0) finalMul *= 0.7; // 10% chance for 30% reduction
  if(store.data.bal > 100000) finalMul *= 0.8; // Reduce wins for high balances
  
  // Near-miss psychology
  if(finalMul === 0 && winLines.length === 0){
    Psychology.generateNearMiss();
  }
  
  return { 
    mul: Math.max(0, finalMul), 
    lines:winLines, 
    scatters:scat, 
    freeSpinsAward:freeAward 
  };
}

function setStatus(msg){ 
  $('slotStatus').textContent=msg; 
}

// Optimized reel spinning with hardware acceleration
function spinReel(col, targetStop, duration){
  return new Promise(resolve=>{
    const reel = strips[col];
    const start = performance.now();
    const startOffset = reel.offset;
    const totalSpin = reel.tall.length * 3 + targetStop; // 3 full rotations + target
    
    function animate(now){
      const elapsed = now - start;
      const progress = Math.min(elapsed / duration, 1);
      
      // Optimized easing
      const eased = 1 - Math.pow(1 - progress, 3); // cubic-out
      const currentOffset = startOffset + totalSpin * eased;
      
      reel.offset = currentOffset % reel.tall.length;
      reel.el.style.transform = `translateY(-${(currentOffset % reel.tall.length) * CELL_H}px)`;
      
      if(progress < 1){
        reel.animation = requestAnimationFrame(animate);
      } else {
        reel.offset = targetStop;
        reel.el.style.transform = `translateY(-${targetStop * CELL_H}px)`;
        resolve();
      }
    }
    
    reel.animation = requestAnimationFrame(animate);
    reelAnimations.push({cancel: () => {
      if(reel.animation) cancelAnimationFrame(reel.animation);
    }});
  });
}

/* Spin logic with house advantage */
async function spinOnce(){
  if(spinning) return;
  const bet = Math.max(1, Math.floor(+$('bet').value||0));
  if(store.data.bal<bet && freeSpins<=0){ 
    toast('üí∞ Insufficient balance - Add more credits!'); 
    return; 
  }

  spinning=true; 
  $('spinBtn').disabled=true; 
  $('autoBtn').disabled=true;
  
  if(freeSpins<=0){ 
    store.data.bal -= bet; 
    updateBal(); 
    store.data.totalLoss += bet;
  } else { 
    setStatus(`Free Spins: ${freeSpins}`); 
    freeSpins--; 
  }

  store.data.spins++; 
  $('statSpins').textContent=store.data.spins;
  beep(900,.06,'triangle',.2);

  Fair.nonce++; 
  $('nonce').textContent=String(Fair.nonce);
  
  // Generate outcomes with added house edge
  const targets=[];
  for(let c=0;c<COLS;c++){
    const hex = await hmac(Fair.serverSeed, `${Fair.clientSeed}:${Fair.nonce}:SLOTS5X3:${c}`);
    let u = uniFromHex(hex);
    
    // House edge manipulation - bias towards low-paying symbols
    if(Math.random() < 0.3) u = u * 0.7 + 0.3; // Push towards higher indices (lower-paying symbols)
    
    const tall = strips[c].tall;
    const stop = Math.floor(u*tall.length);
    targets.push(stop);
  }

  // Animate with stagger
  const durBase=1000, stagger=120; // Slightly faster for better UX
  await Promise.all(targets.map((stop,c)=>spinReel(c, stop, durBase + c*stagger)));

  captureGrid();
  const {mul, lines, scatters, freeSpinsAward} = computePayout(bet);
  let win = Math.floor(bet*mul);

  if(win>0){
    store.data.bal += win; 
    updateBal();
    store.data.won += win;
    store.data.biggest = Math.max(store.data.biggest, win);
    store.data.streak++;
    store.data.lastWin = store.data.spins;
    
    $('statBig').textContent = fmt(store.data.biggest);
    $('streakCount').textContent = store.data.streak;
    
    setStatus(`Win x${mul.toFixed(2)} ‚Üí +${fmt(win)} ${freeSpinsAward?` ¬∑ +${freeSpinsAward} FS`:''}`);
    displayWin(lines, mul);
    beep(1200,.08,'sine',.25); 
    setTimeout(()=>beep(1400,.08,'sine',.22),120);
    store.pushHistory({t:Date.now(), game:'Slots', bet, win, mul:+mul.toFixed(2)});
  } else {
    store.data.streak = 0;
    $('streakCount').textContent = store.data.streak;
    setStatus(scatters>=3 ? `Free Spins +${freeSpinsAward}` : 'No win - Try again!');
    store.pushHistory({t:Date.now(), game:'Slots', bet, win:0, mul:0});
  }

  if(freeSpinsAward>0) freeSpins += freeSpinsAward;

  // Update psychology systems
  Psychology.updateBonusProgress();
  Psychology.adjustVolatility();

  // Calculate and display RTP
  const totalWagered = store.data.spins * (store.data.won + store.data.totalLoss) / store.data.spins;
  const rtp = store.data.won / Math.max(1, totalWagered) * 100;
  $('statRTP').textContent = rtp.toFixed(1) + '%';

  $('revealSrv').textContent = Fair.serverSeed.slice(0,12)+'...';
  
  spinning=false; 
  $('spinBtn').disabled=false; 
  $('autoBtn').disabled=false;
  store.save();
}

// Auto-play with house advantage
let autoSpinning = false;
$('spinBtn').onclick = spinOnce;
$('autoBtn').onclick = ()=>{
  if(autoSpinning) {
    autoSpinning = false;
    $('autoBtn').textContent = 'Auto (25)';
    return;
  }
  
  autoSpinning = true;
  autoLeft = 25;
  $('autoBtn').textContent = 'Stop Auto';
  
  const autoSpin = async ()=>{
    if(!autoSpinning || autoLeft <= 0) {
      autoSpinning = false;
      $('autoBtn').textContent = 'Auto (25)';
      return;
    }
    
    await spinOnce();
    autoLeft--;
    if(autoSpinning && autoLeft > 0) {
      setTimeout(autoSpin, 800); // Slightly faster auto-play
    } else {
      autoSpinning = false;
      $('autoBtn').textContent = 'Auto (25)';
    }
  };
  
  autoSpin();
};

/* =========================
   Optimized Runner Game
========================= */
const canvas = $('runner');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize context
const R = { 
  player:{x:450,y:300,w:30,h:40,dy:0,lane:1,onGround:true}, 
  obst:[], coins:[], score:0, speed:2, playing:false, keys:{}, 
  particles:[], coinCount:0
};

// Optimized game loop with requestAnimationFrame
let gameLoop;
function rUpdate(){
  if(!R.playing) return;
  
  // Clear with solid color (faster than clearRect)
  ctx.fillStyle = '#061018';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Simple player physics
  if(R.keys.up && R.player.onGround){ R.player.dy=-12; R.player.onGround=false; }
  R.player.dy += 0.8; // gravity
  R.player.y += R.player.dy;
  if(R.player.y >= 300){ R.player.y=300; R.player.onGround=true; R.player.dy=0; }
  
  // Lane movement
  const targetY = [250, 300, 350][R.player.lane];
  R.player.y += (targetY - R.player.y) * 0.1;
  
  // Spawn obstacles less frequently for easier gameplay
  if(Math.random() < 0.005 * R.speed) R.obst.push({x:900, y:300+Math.random()*60, w:20, h:30});
  if(Math.random() < 0.008 * R.speed) R.coins.push({x:900, y:250+Math.random()*100, w:15, h:15});
  
  // Update objects
  R.obst = R.obst.filter(o=>{
    o.x -= R.speed * 3;
    return o.x > -50;
  });
  
  R.coins = R.coins.filter(c=>{
    c.x -= R.speed * 3;
    if(c.x < R.player.x+R.player.w && c.x+c.w > R.player.x && 
       c.y < R.player.y+R.player.h && c.y+c.h > R.player.y){
      R.score += 10; R.coinCount++; 
      beep(800, 0.05);
      return false;
    }
    return c.x > -50;
  });
  
  // Simple collision
  for(const o of R.obst){
    if(o.x < R.player.x+R.player.w && o.x+o.w > R.player.x && 
       o.y < R.player.y+R.player.h && o.y+o.h > R.player.y){
      rGameOver();
      break;
    }
  }
  
  // Render optimized
  ctx.fillStyle = '#00ffc6';
  ctx.fillRect(R.player.x, R.player.y, R.player.w, R.player.h);
  
  ctx.fillStyle = '#ff5050';
  R.obst.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));
  
  ctx.fillStyle = '#ffd166';
  R.coins.forEach(c => ctx.fillRect(c.x, c.y, c.w, c.h));
  
  // Update UI
  $('rScore').textContent = R.score;
  $('rCoins').textContent = R.coinCount;
  $('rSpeed').textContent = (R.speed * 0.5).toFixed(1) + '√ó';
  
  R.speed += 0.001; // Gradual speed increase
  
  gameLoop = requestAnimationFrame(rUpdate);
}

function rReset(){
  R.player = {x:450,y:300,w:30,h:40,dy:0,lane:1,onGround:true};
  R.obst = []; R.coins = []; R.score = 0; R.speed = 2; R.coinCount = 0;
}

function rGameOver(){
  R.playing = false;
  if(gameLoop) cancelAnimationFrame(gameLoop);
  
  const coins = R.coinCount * 10;
  store.data.bal += coins;
  updateBal();
  toast(`Game Over! Earned ${coins} credits!`);
  beep(400, 0.2);
  store.pushHistory({t:Date.now(), game:'Runner', bet:0, win:coins, score:R.score});
}

// Controls
const handleKey = (e, pressed) => {
  if(e.key === 'ArrowUp' || e.key === ' ') { R.keys.up = pressed; e.preventDefault(); }
  if(e.key === 'ArrowLeft') R.player.lane = Math.max(0, R.player.lane-1);
  if(e.key === 'ArrowRight') R.player.lane = Math.min(2, R.player.lane+1);
};

document.addEventListener('keydown', e => handleKey(e, true));
document.addEventListener('keyup', e => handleKey(e, false));

$('rStart').onclick=()=>{ 
  if(!R.playing){ rReset(); R.playing=true; gameLoop = requestAnimationFrame(rUpdate); } 
};
$('rPause').onclick=()=>{ 
  R.playing=!R.playing; 
  if(R.playing) gameLoop = requestAnimationFrame(rUpdate);
  else if(gameLoop) cancelAnimationFrame(gameLoop);
};
$('rHelp').onclick=()=>toast('Use arrow keys to move and jump. Collect coins, avoid obstacles!');

/* =========================
   Optimized Rendering
========================= */
const renderRecent = ()=>{
  const r = $('recent');
  r.innerHTML = store.data.history.slice(0,10).map(h => {
    const t = new Date(h.t).toLocaleTimeString();
    const cl = h.win > 0 ? 'style="color:#2af07a"' : '';
    return `<div ${cl}>${t} ${h.game} ${h.win>0 ? '+'+fmt(h.win) : 'LOSS'}</div>`;
  }).join('');
};

const renderLB = ()=>{
  const lb = $('lb');
  lb.innerHTML = store.data.leaderboard.slice(0,10).map((entry,i) =>
    `<div>${i+1}. ${entry.name}: ${fmt(entry.score)} (${entry.time.split(',')[0]})</div>`
  ).join('');
};

const renderMissions = () => {
  const m = $('missions');
  const missions = [
    { id: 'spin100', desc: 'Spin 100 times', target: 100, current: store.data.spins, reward: 5000 },
    { id: 'win10k', desc: 'Win 10,000 credits', target: 10000, current: store.data.won, reward: 2000 },
    { id: 'streak5', desc: 'Win streak of 5', target: 5, current: store.data.streak, reward: 1000 }
  ];
  
  m.innerHTML = missions.map(mission => {
    const progress = Math.min(100, (mission.current / mission.target) * 100);
    const completed = mission.current >= mission.target;
    const claimId = `claim_${mission.id}`;
    
    return `
      <div class="badge" style="width:100%">
        <div>${mission.desc}</div>
        <div class="sub">Progress: ${mission.current}/${mission.target} (${progress.toFixed(0)}%)</div>
        ${completed && !store.data.missions[mission.id] ? 
          `<button id="${claimId}" class="btn" style="margin-top:4px; font-size:10px">Claim ${fmt(mission.reward)}</button>` : 
          completed ? '<div class="sub" style="color:#2af07a">‚úì Completed</div>' : ''
        }
      </div>`;
  }).join('');
  
  // Add claim handlers
  missions.forEach(mission => {
    const claimBtn = $(`claim_${mission.id}`);
    if(claimBtn && !store.data.missions[mission.id]) {
      claimBtn.onclick = () => {
        store.data.bal += mission.reward;
        store.data.missions[mission.id] = true;
        updateBal();
        toast(`üéâ Mission completed! +${fmt(mission.reward)} credits!`);
        store.save();
        renderMissions();
      };
    }
  });
};

const refreshAll = () => {
  updateBal();
  $('bet').value = store.data.bet;
  $('streakCount').textContent = store.data.streak;
  SFX_ON = store.data.sfx;
  applyTheme();
  renderRecent();
  renderLB();
  renderMissions();
};

/* =========================
   Optimized Confetti System
========================= */
const confettiBurst = (rect, count = 20) => {
  if(!SFX_ON) return; // Skip if sound off
  
  const colors = ['#00ffc6', '#ff3d81', '#ffd166', '#2af07a'];
  const container = document.body;
  const particles = [];
  
  for(let i = 0; i < Math.min(count, 50); i++) { // Limit particles
    const particle = document.createElement('div');
    particle.className = 'spark';
    particle.style.position = 'fixed';
    particle.style.left = (rect.left + rect.width/2) + 'px';
    particle.style.top = (rect.top + rect.height/2) + 'px';
    particle.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
    particle.style.pointerEvents = 'none';
    particle.style.zIndex = '1000';
    
    container.appendChild(particle);
    particles.push(particle);
    
    // Animate with transform for better performance
    const vx = (Math.random()-0.5) * 200;
    const vy = (Math.random()-0.5) * 200;
    
    particle.animate([
      { transform: 'translate(0,0) scale(1)', opacity: 1 },
      { transform: `translate(${vx}px,${vy}px) scale(0)`, opacity: 0 }
    ], {
      duration: 1000,
      easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
    }).onfinish = () => {
      if(particle.parentNode) particle.parentNode.removeChild(particle);
    };
  }
};

$('confettiTest').onclick = () => confettiBurst({left:400, top:300, width:100, height:100}, 30);

/* =========================
   Initialization
========================= */
async function init(){
  try {
    store.load();
    await Fair.newPack();
    buildReels();
    refreshAll();
    
    // Auto-save every 30 seconds
    setInterval(() => store.save(), 30000);
    
    toast('üé∞ Welcome to GO-GAMBLER! Good luck!');
  } catch(error) {
    console.error('Initialization error:', error);
    toast('‚ö†Ô∏è Error loading game');
  }
}

// Start when page loads
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  store.save();
  reelAnimations.forEach(anim => anim.cancel());
  if(gameLoop) cancelAnimationFrame(gameLoop);
});
</script>
</body>
</html>
